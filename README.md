[![pipeline status](https://github.com/verrazzano/verrazzano-operator/badges/master/pipeline.svg)](https://github.com/verrazzano/verrazzano-operator/commits/master)
[![coverage report](https://github.com/verrazzano/verrazzano-operator/badges/master/coverage.svg)](https://github.com/verrazzano/verrazzano-operator/commits/master)
# Verrazzano Operator

The Verrazzano Operator is the Kubernetes operator that runs in the Verrazzano Management Cluster, 
watches local CRDs for models/bindings, and launches micro operators into Verrazzano Managed Clusters.

## Project Status

Current functionality:
- Learns about Managed Clusters through a "VerrazzanoManagedCluster" CR, and creates k8s clients and watchers to those
clusters.
- Watches the local k8s cluster for VerrazzanoModel and VerrazzanoBinding CRs.
- A VerrazzanoModel/VerrazzanoBinding pair describes a Verrazzano application and defines which application components
should be installed on which VerrazzanoManagedCluster.
- On creation or update of a VerrazzanoModel/VerrazzanoBinding pair, the Verrazzano Operator launches:
  - Into the Management Cluster:
    - A Verrazzano Monitoring instance.
  - Into the Managed Cluster for each "component":
    - TBD - Need to add more details here.  A WeblogicApplication CR.  This is also just a dummy CR for now.  This would get replaced by one of the real, eventual CRs that the
  micro-operators will act on.
    - TBD - Need to mention other micro operators.
    - Agents forwarding logs and metrics to the VerrazzanoMonitoringInstance. 

- On deletion of a VerrazzanoBinding, deletes all related resources deployed above.
- On updates to the Managed Cluster's objects (deployments, WeblogicApplication CRs) created by the Verrazzano Operator,
triggers a reprocessing of the owning VerrazzanoBinding.  This causes any drift in expecting state to immediately
be fixed by the Verrazzano Operator.

# Verrazzano Helm Chart

The `chart` directory contains helm chart for Verrazzano that packages together the core elements that will be installed into the Verrazzano Management Cluster - micro operators,
verrazzano-operator, verrazzano-monitoring-operator, etc - into a single Helm chart.

### Chart storage

https://objectstorage.us-phoenix-1.oraclecloud.com/n/stevengreenberginc/b/verrazzano-helm-chart/o/

### Chart Parameters

See `./chart/values.yaml` for the full list of configurable parameters that can be set using
`--set parameter=value` when installing the Helm chart.

### Building chart
`make chart-build TAG_NAME=$tag` will build the chart archive in `dist` directory. The `OPERATOR_VERSION` attribute in `values.yaml` of resulting chart will be replaced with tag specified by input `tag`.

### Publishing chart
`make chart-publish TAG_NAME=$tag` will build the chart and publish to chart repository with tag specified by input `tag`.

## Artifacts

On a successful release (which occurs on a Git tag), this repo 
- publises a Docker image: `container-registry.oracle.com/verrazzano/verrazzano-operator:tag`
- publishes a new version of Verrazzano-helm-chart at `https://objectstorage.us-phoenix-1.oraclecloud.com/n/stevengreenberginc/b/verrazzano-helm-chart/o/`


## Building

Go build:
```
make go-install
```

Docker build:
```
export ACCESS_USERNAME=<username with read access to github verrazzano project>
export ACCESS_PASSWORD=<password for account with read access to github verrazzano project>
make docker-build
```

Docker push:
```
make docker-push
```

## Updating the CRDs

The CRDs are auto generated by the Verrazzano project `verrazzano-crd-generator`.  The steps to include changes made to the yaml files that create the CRDs are:

* Make the API changes in the `verrazzano-crd-generator` project
* Tag the master branch of `verrazzano-crd-generator` (e.g. 0.n)
* Edit `go.mod` to use the newly tagged API changes.  For example `github.com/verrazzano/verrazzano-coh-cluster-operator v1.2.0`
* make go-install

## Running

First, as a one-time operation, create relevant CRDs in the cluster where you'll be running the Verrazzano Operator:

```
kubectl apply -f vendor/github.com/verrazzano/verrazzano-crd-generator/deploy/crds/verrazzano_v1beta1_verrazzanomanagedcluster_crd.yaml
kubectl apply -f vendor/github.com/verrazzano/verrazzano-crd-generator/deploy/crds/verrazzano_v1beta1_verrazzanobinding_crd.yaml
kubectl apply -f vendor/github.com/verrazzano/verrazzano-crd-generator/deploy/crds/verrazzano_v1beta1_verrazzanomodel_crd.yaml
```

### Running locally

While developing, it's usually most efficient to run the Verrazzano Operator as an out-of-cluster process,
pointing it to your Kubernetes cluster:

```
export KUBECONFIG=<your_kubeconfig>
make go-run
```

### Running in a Kubernetes Cluster

```
kubectl apply -f ./k8s/manifests/verrazzano-operator-serviceaccount.yaml
kubectl apply -f ./k8s/manifests/verrazzano-operator-deployment.yaml
```

**Note:** - if you don't intend to use the latest official Docker image, fill in your own Docker image in
`verrazzano-operator-deployment.yaml` above.

## Demo

First, install the Verrazzano Operator using one of the approaches above.  Now, make it aware of 2 Managed Clusters (you
can set these to be same as the cluster running the Super Domain Operator if you are short on clusters:

```
# For now, make sure that your kubeconfig files are literally called "kubeconfig"
export MANAGED1_KUBECONFIG=<my_kubeconfig1>
export MANAGED2_KUBECONFIG=<my_kubeconfig2>

kubectl delete secret managed-cluster1
kubectl create secret generic managed-cluster1 --from-file=$MANAGED1_KUBECONFIG
kubectl apply -f k8s/examples/managed-cluster1.yaml

kubectl delete secret managed-cluster2
kubectl create secret generic managed-cluster2 --from-file=$MANAGED2_KUBECONFIG
kubectl apply -f k8s/examples/managed-cluster2.yaml
```

Then create a VerrazzanoBinding:
```
kubectl apply -f k8s/examples/app-binding.yaml
```

And view the artifacts that have been created in Managed Cluster1:

```
kubectl get pod,serviceaccounts --all-namespaces -l 'k8s-app=verrazzano.io'
NAMESPACE                       NAME                                                   READY   STATUS    RESTARTS   AGE
monitoring                      pod/verrazzano-prom-pusher-69b57c4986-snvgb            1/1     Running   0          18m
verrazzano-bobs-books-binding   pod/verrazzano-coh-cluster-operator-7dcc8c48d6-4qmwg   1/1     Running   0          18m
verrazzano-bobs-books-binding   pod/verrazzano-helidon-app-operator-6b84c5dbc9-2shgq   1/1     Running   0          18m
verrazzano-bobs-books-binding   pod/verrazzano-wko-operator-846db5747-szzgz            1/1     Running   0          18m

NAMESPACE                       NAME                                           SECRETS   AGE
bob                             serviceaccount/verrazzano-bobs-books-binding   1         18m
bobby                           serviceaccount/verrazzano-bobs-books-binding   1         18m
monitoring                      serviceaccount/verrazzano-bobs-books-binding   1         18m
verrazzano-bobs-books-binding   serviceaccount/verrazzano-bobs-books-binding   1         18m
wls-operator                    serviceaccount/verrazzano-bobs-books-binding   1         18m
```

And Managed Cluster2:

```
kubectl get pod,serviceaccounts --all-namespaces -l 'k8s-app=verrazzano.io'
NAMESPACE                       NAME                                                   READY   STATUS    RESTARTS   AGE
monitoring                      pod/verrazzano-prom-pusher-969746f55-swvrz             1/1     Running   0          19m
verrazzano-bobs-books-binding   pod/verrazzano-coh-cluster-operator-59684b8bc-j7467    1/1     Running   0          19m
verrazzano-bobs-books-binding   pod/verrazzano-helidon-app-operator-5955d6b874-246gh   1/1     Running   0          19m

NAMESPACE                       NAME                                           SECRETS   AGE
monitoring                      serviceaccount/verrazzano-bobs-books-binding   1         19m
robert                          serviceaccount/verrazzano-bobs-books-binding   1         19m
verrazzano-bobs-books-binding   serviceaccount/verrazzano-bobs-books-binding   1         19m
```

## Development

### Running Tests

To run unit tests:

```
make unit-test
```

To run integration tests:

```
make integ-test
```

## Generating/Updating THIRD_PARTY_LICENSES.txt

Whenever project dependencies (go.mod) are updated, the `THIRD_PARTY_LICENSES.txt` file contained in this project must be updated as well.
This is verified in the CI pipeline - the build will fail if this file is found to be out of sync with
go.mod.

To update the `THIRD_PARTY_LICENSES.txt` file, install the *Attribution Helper* tool as described [here](https://github.com/oracle/attribution-helper#how-to-use),
run it within this project's root directory:

```
attribution-helper gen
```

and then commit the updated `THIRD_PARTY_LICENSES.txt` file.
